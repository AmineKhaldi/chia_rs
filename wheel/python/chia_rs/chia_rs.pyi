
#
# this file is generated by generate_type_stubs.py
#

from typing import List, Optional, Sequence, Tuple, Union, Dict, Any, ClassVar, final
from .sized_bytes import bytes32, bytes100
from .sized_ints import uint8, uint16, uint32, uint64, uint128, int8, int16, int32, int64
from chia.types.blockchain_format.program import Program as ChiaProgram

ReadableBuffer = Union[bytes, bytearray, memoryview]

class _Unspec:
    pass

def solution_generator(spends: Sequence[Tuple[Coin, bytes, bytes]]) -> bytes: ...
def solution_generator_backrefs(spends: Sequence[Tuple[Coin, bytes, bytes]]) -> bytes: ...

def compute_merkle_set_root(items: Sequence[bytes]) -> bytes: ...

def supports_fast_forward(spend: CoinSpend) -> bool : ...
def fast_forward_singleton(spend: CoinSpend, new_coin: Coin, new_parent: Coin) -> bytes: ...

def run_block_generator(
    program: ReadableBuffer, args: List[ReadableBuffer], max_cost: int, flags: int, constants: ConsensusConstants
) -> Tuple[Optional[int], Optional[SpendBundleConditions]]: ...

def run_block_generator2(
    program: ReadableBuffer, args: List[ReadableBuffer], max_cost: int, flags: int, constants: ConsensusConstants
) -> Tuple[Optional[int], Optional[SpendBundleConditions]]: ...

def run_puzzle(
    puzzle: bytes, solution: bytes, parent_id: bytes32, amount: int, max_cost: int, flags: int, constants: ConsensusConstants
) -> SpendBundleConditions: ...

def deserialize_proof(
    proof: bytes
) -> MerkleSet: ...

def confirm_included_already_hashed(
    root: bytes32,
    item: bytes32,
    proof: bytes,
) -> bool: ...

def confirm_not_included_already_hashed(
    root: bytes32,
    item: bytes32,
    proof: bytes,
) -> bool: ...

def validate_clvm_and_signature(
    new_spend: SpendBundle,
    max_cost: int,
    constants: ConsensusConstants,
    peak_height: int,
) -> Tuple[SpendBundleConditions, List[Tuple[bytes32, GTElement]], float]: ...

def get_conditions_from_spendbundle(
    spend_bundle: SpendBundle,
    max_cost: int,
    constants: ConsensusConstants,
    height: int,
) -> SpendBundleConditions: ...

def get_flags_for_height_and_constants(
    height: int,
    constants: ConsensusConstants
) -> int: ...


NO_UNKNOWN_CONDS: int = ...
STRICT_ARGS_COUNT: int = ...
LIMIT_HEAP: int = ...
DISALLOW_INFINITY_G1: int = ...
MEMPOOL_MODE: int = ...
ENABLE_BLS_OPS_OUTSIDE_GUARD: int = ...
ENABLE_FIXED_DIV: int = ...
ALLOW_BACKREFS: int = ...

ELIGIBLE_FOR_DEDUP: int = ...
ELIGIBLE_FOR_FF: int = ...

NO_UNKNOWN_OPS: int = ...

def run_chia_program(
    program: bytes, args: bytes, max_cost: int, flags: int
) -> Tuple[int, LazyNode]: ...

class LazyNode:
    pair: Optional[Tuple[LazyNode, LazyNode]]
    atom: Optional[bytes]

def serialized_length(program: ReadableBuffer) -> int: ...
def tree_hash(program: ReadableBuffer) -> bytes32: ...
def get_puzzle_and_solution_for_coin(program: ReadableBuffer, args: ReadableBuffer, max_cost: int, find_parent: bytes32, find_amount: int, find_ph: bytes32, flags: int) -> Tuple[bytes, bytes]: ...
def get_puzzle_and_solution_for_coin2(program: Program, block_refs: List[ReadableBuffer], max_cost: int, find_coin: Coin, flags: int) -> Tuple[Program, Program]: ...

@final
class BLSCache:
    def __init__(self, cache_size: Optional[int] = 50000) -> None: ...
    def len(self) -> int: ...
    def aggregate_verify(self, pks: List[G1Element], msgs: List[bytes], sig: G2Element) -> bool: ...
    def items(self) -> List[Tuple[bytes, bytes]]: ...
    def update(self, other: List[Tuple[bytes, bytes]]) -> None: ...

@final
class AugSchemeMPL:
    @staticmethod
    def sign(pk: PrivateKey, msg: bytes, prepend_pk: Optional[G1Element] = None) -> G2Element: ...
    @staticmethod
    def aggregate(sigs: Sequence[G2Element]) -> G2Element: ...
    @staticmethod
    def verify(pk: G1Element, msg: bytes, sig: G2Element) -> bool: ...
    @staticmethod
    def aggregate_verify(pks: Sequence[G1Element], msgs: Sequence[bytes], sig: G2Element) -> bool: ...
    @staticmethod
    def key_gen(seed: bytes) -> PrivateKey: ...
    @staticmethod
    def g2_from_message(msg: bytes) -> G2Element: ...
    @staticmethod
    def derive_child_sk(pk: PrivateKey, index: int) -> PrivateKey: ...
    @staticmethod
    def derive_child_sk_unhardened(pk: PrivateKey, index: int) -> PrivateKey: ...
    @staticmethod
    def derive_child_pk_unhardened(pk: G1Element, index: int) -> G1Element: ...

class MerkleSet:
    def get_root(self) -> bytes32: ...
    def is_included_already_hashed(self, to_check: bytes) -> Tuple[bool, bytes]: ...
    def __init__(
        self,
        leafs: List[bytes32],
    ) -> None: ...

@final
class G1Element:
    SIZE: ClassVar[int] = ...
    def __new__(cls) -> G1Element: ...
    def get_fingerprint(self) -> int: ...
    def verify(self, signature: G2Element, msg: bytes) -> bool: ...
    def pair(self, other: G2Element) -> GTElement: ...
    @staticmethod
    def generator() -> G1Element: ...
    def __str__(self) -> str: ...
    def __add__(self, other: G1Element) -> G1Element: ...
    def __iadd__(self, other: G1Element) -> G1Element: ...
    def derive_unhardened(self, int) -> G1Element: ...
    def __init__(
        self
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> G1Element: ...
    def __copy__(self) -> G1Element: ...
    @staticmethod
    def from_bytes(bytes) -> G1Element: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> G1Element: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[G1Element, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> G1Element: ...

@final
class G2Element:
    SIZE: ClassVar[int] = ...
    def __new__(cls) -> G2Element: ...
    def pair(self, other: G1Element) -> GTElement: ...
    @staticmethod
    def generator() -> G2Element: ...
    def __str__(self) -> str: ...
    def __add__(self, other: G2Element) -> G2Element: ...
    def __iadd__(self, other: G2Element) -> G2Element: ...
    def __init__(
        self
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> G2Element: ...
    def __copy__(self) -> G2Element: ...
    @staticmethod
    def from_bytes(bytes) -> G2Element: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> G2Element: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[G2Element, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> G2Element: ...

@final
class GTElement:
    SIZE: ClassVar[int] = ...
    def __str__(self) -> str: ...
    def __mul__(self, rhs: GTElement) -> GTElement: ...
    def __imul__(self, rhs: GTElement) -> GTElement : ...
    def __init__(
        self
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> GTElement: ...
    def __copy__(self) -> GTElement: ...
    @staticmethod
    def from_bytes(bytes) -> GTElement: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> GTElement: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[GTElement, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> GTElement: ...

@final
class PrivateKey:
    PRIVATE_KEY_SIZE: ClassVar[int] = ...
    def sign(self, msg: bytes, final_pk: Optional[G1Element] = None) -> G2Element: ...
    def get_g1(self) -> G1Element: ...
    def __str__(self) -> str: ...
    def public_key(self) -> G1Element: ...
    def derive_hardened(self, int) -> PrivateKey: ...
    def derive_unhardened(self, int) -> PrivateKey: ...
    @staticmethod
    def from_seed(bytes) -> PrivateKey: ...
    def __init__(
        self
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> PrivateKey: ...
    def __copy__(self) -> PrivateKey: ...
    @staticmethod
    def from_bytes(bytes) -> PrivateKey: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> PrivateKey: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[PrivateKey, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> PrivateKey: ...

@final
class SpendConditions:
    coin_id: bytes
    parent_id: bytes
    puzzle_hash: bytes
    coin_amount: int
    height_relative: Optional[int]
    seconds_relative: Optional[int]
    before_height_relative: Optional[int]
    before_seconds_relative: Optional[int]
    birth_height: Optional[int]
    birth_seconds: Optional[int]
    create_coin: List[Tuple[bytes, int, Optional[bytes]]]
    agg_sig_me: List[Tuple[G1Element, bytes]]
    agg_sig_parent: List[Tuple[G1Element, bytes]]
    agg_sig_puzzle: List[Tuple[G1Element, bytes]]
    agg_sig_amount: List[Tuple[G1Element, bytes]]
    agg_sig_puzzle_amount: List[Tuple[G1Element, bytes]]
    agg_sig_parent_amount: List[Tuple[G1Element, bytes]]
    agg_sig_parent_puzzle: List[Tuple[G1Element, bytes]]
    flags: int
    def __init__(
        self,
        coin_id: bytes,
        parent_id: bytes,
        puzzle_hash: bytes,
        coin_amount: int,
        height_relative: Optional[int],
        seconds_relative: Optional[int],
        before_height_relative: Optional[int],
        before_seconds_relative: Optional[int],
        birth_height: Optional[int],
        birth_seconds: Optional[int],
        create_coin: Sequence[Tuple[bytes, int, Optional[bytes]]],
        agg_sig_me: Sequence[Tuple[G1Element, bytes]],
        agg_sig_parent: Sequence[Tuple[G1Element, bytes]],
        agg_sig_puzzle: Sequence[Tuple[G1Element, bytes]],
        agg_sig_amount: Sequence[Tuple[G1Element, bytes]],
        agg_sig_puzzle_amount: Sequence[Tuple[G1Element, bytes]],
        agg_sig_parent_amount: Sequence[Tuple[G1Element, bytes]],
        agg_sig_parent_puzzle: Sequence[Tuple[G1Element, bytes]],
        flags: int
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> SpendConditions: ...
    def __copy__(self) -> SpendConditions: ...
    @staticmethod
    def from_bytes(bytes) -> SpendConditions: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> SpendConditions: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[SpendConditions, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> SpendConditions: ...
    def replace(self, *, coin_id: Union[ bytes, _Unspec] = _Unspec(),
        parent_id: Union[ bytes, _Unspec] = _Unspec(),
        puzzle_hash: Union[ bytes, _Unspec] = _Unspec(),
        coin_amount: Union[ int, _Unspec] = _Unspec(),
        height_relative: Union[ Optional[int], _Unspec] = _Unspec(),
        seconds_relative: Union[ Optional[int], _Unspec] = _Unspec(),
        before_height_relative: Union[ Optional[int], _Unspec] = _Unspec(),
        before_seconds_relative: Union[ Optional[int], _Unspec] = _Unspec(),
        birth_height: Union[ Optional[int], _Unspec] = _Unspec(),
        birth_seconds: Union[ Optional[int], _Unspec] = _Unspec(),
        create_coin: Union[ List[Tuple[bytes, int, Optional[bytes]]], _Unspec] = _Unspec(),
        agg_sig_me: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_parent: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_puzzle: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_amount: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_puzzle_amount: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_parent_amount: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        agg_sig_parent_puzzle: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        flags: Union[ int, _Unspec] = _Unspec()) -> SpendConditions: ...

@final
class SpendBundleConditions:
    spends: List[SpendConditions]
    reserve_fee: int
    height_absolute: int
    seconds_absolute: int
    before_height_absolute: Optional[int]
    before_seconds_absolute: Optional[int]
    agg_sig_unsafe: List[Tuple[G1Element, bytes]]
    cost: int
    removal_amount: int
    addition_amount: int
    def __init__(
        self,
        spends: Sequence[SpendConditions],
        reserve_fee: int,
        height_absolute: int,
        seconds_absolute: int,
        before_height_absolute: Optional[int],
        before_seconds_absolute: Optional[int],
        agg_sig_unsafe: Sequence[Tuple[G1Element, bytes]],
        cost: int,
        removal_amount: int,
        addition_amount: int
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> SpendBundleConditions: ...
    def __copy__(self) -> SpendBundleConditions: ...
    @staticmethod
    def from_bytes(bytes) -> SpendBundleConditions: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> SpendBundleConditions: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[SpendBundleConditions, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> SpendBundleConditions: ...
    def replace(self, *, spends: Union[ List[SpendConditions], _Unspec] = _Unspec(),
        reserve_fee: Union[ int, _Unspec] = _Unspec(),
        height_absolute: Union[ int, _Unspec] = _Unspec(),
        seconds_absolute: Union[ int, _Unspec] = _Unspec(),
        before_height_absolute: Union[ Optional[int], _Unspec] = _Unspec(),
        before_seconds_absolute: Union[ Optional[int], _Unspec] = _Unspec(),
        agg_sig_unsafe: Union[ List[Tuple[G1Element, bytes]], _Unspec] = _Unspec(),
        cost: Union[ int, _Unspec] = _Unspec(),
        removal_amount: Union[ int, _Unspec] = _Unspec(),
        addition_amount: Union[ int, _Unspec] = _Unspec()) -> SpendBundleConditions: ...

@final
class BlockRecord:
    header_hash: bytes32
    prev_hash: bytes32
    height: uint32
    weight: uint128
    total_iters: uint128
    signage_point_index: uint8
    challenge_vdf_output: ClassgroupElement
    infused_challenge_vdf_output: Optional[ClassgroupElement]
    reward_infusion_new_challenge: bytes32
    challenge_block_info_hash: bytes32
    sub_slot_iters: uint64
    pool_puzzle_hash: bytes32
    farmer_puzzle_hash: bytes32
    required_iters: uint64
    deficit: uint8
    overflow: bool
    prev_transaction_block_height: uint32
    timestamp: Optional[uint64]
    prev_transaction_block_hash: Optional[bytes32]
    fees: Optional[uint64]
    reward_claims_incorporated: Optional[List[Coin]]
    finished_challenge_slot_hashes: Optional[List[bytes32]]
    finished_infused_challenge_slot_hashes: Optional[List[bytes32]]
    finished_reward_slot_hashes: Optional[List[bytes32]]
    sub_epoch_summary_included: Optional[SubEpochSummary]
    is_transaction_block: bool
    first_in_sub_slot: bool
    def is_challenge_block(self, constants: ConsensusConstants) -> bool: ...
    def sp_sub_slot_total_iters(self, constants: ConsensusConstants) -> uint128: ...
    def ip_sub_slot_total_iters(self, constants: ConsensusConstants) -> uint128: ...
    def sp_iters(self, constants: ConsensusConstants) -> uint64: ...
    def ip_iters(self, constants: ConsensusConstants) -> uint64: ...
    def sp_total_iters(self, constants: ConsensusConstants) -> uint128: ...
    def __init__(
        self,
        header_hash: bytes,
        prev_hash: bytes,
        height: uint32,
        weight: uint128,
        total_iters: uint128,
        signage_point_index: uint8,
        challenge_vdf_output: ClassgroupElement,
        infused_challenge_vdf_output: Optional[ClassgroupElement],
        reward_infusion_new_challenge: bytes,
        challenge_block_info_hash: bytes,
        sub_slot_iters: uint64,
        pool_puzzle_hash: bytes,
        farmer_puzzle_hash: bytes,
        required_iters: uint64,
        deficit: uint8,
        overflow: bool,
        prev_transaction_block_height: uint32,
        timestamp: Optional[uint64],
        prev_transaction_block_hash: Optional[bytes32],
        fees: Optional[uint64],
        reward_claims_incorporated: Optional[Sequence[Coin]],
        finished_challenge_slot_hashes: Optional[Sequence[bytes32]],
        finished_infused_challenge_slot_hashes: Optional[Sequence[bytes32]],
        finished_reward_slot_hashes: Optional[Sequence[bytes32]],
        sub_epoch_summary_included: Optional[SubEpochSummary]
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> BlockRecord: ...
    def __copy__(self) -> BlockRecord: ...
    @staticmethod
    def from_bytes(bytes) -> BlockRecord: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> BlockRecord: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[BlockRecord, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> BlockRecord: ...
    def replace(self, *, header_hash: Union[ bytes32, _Unspec] = _Unspec(),
        prev_hash: Union[ bytes32, _Unspec] = _Unspec(),
        height: Union[ uint32, _Unspec] = _Unspec(),
        weight: Union[ uint128, _Unspec] = _Unspec(),
        total_iters: Union[ uint128, _Unspec] = _Unspec(),
        signage_point_index: Union[ uint8, _Unspec] = _Unspec(),
        challenge_vdf_output: Union[ ClassgroupElement, _Unspec] = _Unspec(),
        infused_challenge_vdf_output: Union[ Optional[ClassgroupElement], _Unspec] = _Unspec(),
        reward_infusion_new_challenge: Union[ bytes32, _Unspec] = _Unspec(),
        challenge_block_info_hash: Union[ bytes32, _Unspec] = _Unspec(),
        sub_slot_iters: Union[ uint64, _Unspec] = _Unspec(),
        pool_puzzle_hash: Union[ bytes32, _Unspec] = _Unspec(),
        farmer_puzzle_hash: Union[ bytes32, _Unspec] = _Unspec(),
        required_iters: Union[ uint64, _Unspec] = _Unspec(),
        deficit: Union[ uint8, _Unspec] = _Unspec(),
        overflow: Union[ bool, _Unspec] = _Unspec(),
        prev_transaction_block_height: Union[ uint32, _Unspec] = _Unspec(),
        timestamp: Union[ Optional[uint64], _Unspec] = _Unspec(),
        prev_transaction_block_hash: Union[ Optional[bytes32], _Unspec] = _Unspec(),
        fees: Union[ Optional[uint64], _Unspec] = _Unspec(),
        reward_claims_incorporated: Union[ Optional[List[Coin]], _Unspec] = _Unspec(),
        finished_challenge_slot_hashes: Union[ Optional[List[bytes32]], _Unspec] = _Unspec(),
        finished_infused_challenge_slot_hashes: Union[ Optional[List[bytes32]], _Unspec] = _Unspec(),
        finished_reward_slot_hashes: Union[ Optional[List[bytes32]], _Unspec] = _Unspec(),
        sub_epoch_summary_included: Union[ Optional[SubEpochSummary], _Unspec] = _Unspec()) -> BlockRecord: ...

@final
class Message:
    msg_type: int
    id: Optional[uint16]
    data: bytes
    def __init__(
        self,
        msg_type: int,
        id: Optional[uint16],
        data: bytes
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> Message: ...
    def __copy__(self) -> Message: ...
    @staticmethod
    def from_bytes(bytes) -> Message: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> Message: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[Message, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> Message: ...
    def replace(self, *, msg_type: Union[ int, _Unspec] = _Unspec(),
        id: Union[ Optional[uint16], _Unspec] = _Unspec(),
        data: Union[ bytes, _Unspec] = _Unspec()) -> Message: ...

@final
class Handshake:
    network_id: str
    protocol_version: str
    software_version: str
    server_port: uint16
    node_type: int
    capabilities: List[Tuple[uint16, str]]
    def __init__(
        self,
        network_id: str,
        protocol_version: str,
        software_version: str,
        server_port: uint16,
        node_type: int,
        capabilities: Sequence[Tuple[uint16, str]]
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> Handshake: ...
    def __copy__(self) -> Handshake: ...
    @staticmethod
    def from_bytes(bytes) -> Handshake: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> Handshake: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[Handshake, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> Handshake: ...
    def replace(self, *, network_id: Union[ str, _Unspec] = _Unspec(),
        protocol_version: Union[ str, _Unspec] = _Unspec(),
        software_version: Union[ str, _Unspec] = _Unspec(),
        server_port: Union[ uint16, _Unspec] = _Unspec(),
        node_type: Union[ int, _Unspec] = _Unspec(),
        capabilities: Union[ List[Tuple[uint16, str]], _Unspec] = _Unspec()) -> Handshake: ...

@final
class ClassgroupElement:
    data: bytes100
    @staticmethod
    def create(bytes) -> ClassgroupElement: ...
    @staticmethod
    def get_default_element() -> ClassgroupElement: ...
    @staticmethod
    def get_size() -> int: ...
    def __init__(
        self,
        data: bytes100
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> ClassgroupElement: ...
    def __copy__(self) -> ClassgroupElement: ...
    @staticmethod
    def from_bytes(bytes) -> ClassgroupElement: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> ClassgroupElement: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[ClassgroupElement, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> ClassgroupElement: ...
    def replace(self, *, data: Union[ bytes100, _Unspec] = _Unspec()) -> ClassgroupElement: ...

@final
class Coin:
    parent_coin_info: bytes32
    puzzle_hash: bytes32
    amount: uint64
    def name(self) -> bytes32: ...
    def __init__(
        self,
        parent_coin_info: bytes,
        puzzle_hash: bytes,
        amount: uint64
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> Coin: ...
    def __copy__(self) -> Coin: ...
    @staticmethod
    def from_bytes(bytes) -> Coin: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> Coin: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[Coin, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> Coin: ...
    def replace(self, *, parent_coin_info: Union[ bytes32, _Unspec] = _Unspec(),
        puzzle_hash: Union[ bytes32, _Unspec] = _Unspec(),
        amount: Union[ uint64, _Unspec] = _Unspec()) -> Coin: ...

@final
class CoinSpend:
    coin: Coin
    puzzle_reveal: Program
    solution: Program
    def __init__(
        self,
        coin: Coin,
        puzzle_reveal: Program,
        solution: Program
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> CoinSpend: ...
    def __copy__(self) -> CoinSpend: ...
    @staticmethod
    def from_bytes(bytes) -> CoinSpend: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> CoinSpend: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[CoinSpend, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> CoinSpend: ...
    def replace(self, *, coin: Union[ Coin, _Unspec] = _Unspec(),
        puzzle_reveal: Union[ Program, _Unspec] = _Unspec(),
        solution: Union[ Program, _Unspec] = _Unspec()) -> CoinSpend: ...

@final
class CoinState:
    coin: Coin
    spent_height: Optional[uint32]
    created_height: Optional[uint32]
    def __init__(
        self,
        coin: Coin,
        spent_height: Optional[uint32],
        created_height: Optional[uint32]
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> CoinState: ...
    def __copy__(self) -> CoinState: ...
    @staticmethod
    def from_bytes(bytes) -> CoinState: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> CoinState: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[CoinState, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> CoinState: ...
    def replace(self, *, coin: Union[ Coin, _Unspec] = _Unspec(),
        spent_height: Union[ Optional[uint32], _Unspec] = _Unspec(),
        created_height: Union[ Optional[uint32], _Unspec] = _Unspec()) -> CoinState: ...

@final
class EndOfSubSlotBundle:
    challenge_chain: ChallengeChainSubSlot
    infused_challenge_chain: Optional[InfusedChallengeChainSubSlot]
    reward_chain: RewardChainSubSlot
    proofs: SubSlotProofs
    def __init__(
        self,
        challenge_chain: ChallengeChainSubSlot,
        infused_challenge_chain: Optional[InfusedChallengeChainSubSlot],
        reward_chain: RewardChainSubSlot,
        proofs: SubSlotProofs
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> EndOfSubSlotBundle: ...
    def __copy__(self) -> EndOfSubSlotBundle: ...
    @staticmethod
    def from_bytes(bytes) -> EndOfSubSlotBundle: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> EndOfSubSlotBundle: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[EndOfSubSlotBundle, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> EndOfSubSlotBundle: ...
    def replace(self, *, challenge_chain: Union[ ChallengeChainSubSlot, _Unspec] = _Unspec(),
        infused_challenge_chain: Union[ Optional[InfusedChallengeChainSubSlot], _Unspec] = _Unspec(),
        reward_chain: Union[ RewardChainSubSlot, _Unspec] = _Unspec(),
        proofs: Union[ SubSlotProofs, _Unspec] = _Unspec()) -> EndOfSubSlotBundle: ...

@final
class FeeRate:
    mojos_per_clvm_cost: uint64
    def __init__(
        self,
        mojos_per_clvm_cost: uint64
    ) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __richcmp__(self) -> Any: ...
    def __deepcopy__(self) -> FeeRate: ...
    def __copy__(self) -> FeeRate: ...
    @staticmethod
    def from_bytes(bytes) -> FeeRate: ...
    @staticmethod
    def from_bytes_unchecked(bytes) -> FeeRate: ...
    @staticmethod
    def parse_rust(ReadableBuffer, bool = False) -> Tuple[FeeRate, int]: ...
    def to_bytes(self) -> bytes: ...
    def __bytes__(self) -> bytes: ...
    def stream_to_bytes(self) -> bytes: ...
    def get_hash(self) -> bytes32: ...
    def to_json_dict(self) -> Any: ...
    @staticmethod
    def from_json_dict(json_dict: Any) -> FeeRate: ...
    def replace(self, *, mojos_per_clvm_cost: Union[ uint64, _Unspec] = _Unspec()) -> FeeRate: ...
